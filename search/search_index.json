{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\:]","pipeline":["stopWordFilter"]},"docs":[{"location":"cheat-sheet/","title":"Cheat sheet","text":""},{"location":"cheat-sheet/#creating-mocks","title":"Creating Mocks","text":"<p>Mocking a simple class</p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\n</code></pre> <p>Mocking an interface</p> <pre><code>$mock = Phake::mock(MyInterface::class);\n</code></pre> <p>Mocking multiple interfaces</p> <pre><code>$mock = Phake::mock([ MyInterface1::class, MyInterface2::class ]);\n</code></pre> <p>Create a partial Mock</p> <pre><code>$mock = Phake::partialMock(MyClassToMock::class, ...$constructorParams);\n</code></pre>"},{"location":"cheat-sheet/#method-stubbing","title":"Method stubbing","text":"<p>Stubbing a simple call to the <code>calledMethod()</code></p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod('someParameter')-&gt;thenReturn('My return value');\n</code></pre> <p>Stubbing multiple calls to <code>calledMethod()</code> with different parameters</p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod('someParameter')-&gt;thenReturn('My return value');\nPhake::when($mock)-&gt;calledMethod('someOtherParameter')-&gt;thenReturn('My other return value');\n</code></pre> <p>Stub calls to <code>calledMethod()</code> regardless of parameters.</p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod(Phake::anyParameters())-&gt;thenReturn($result);\n\n// or the shorter version\n\nPhake::when($mock)-&gt;calledMethod-&gt;thenReturn($result);\n</code></pre> <p>Stub call to <code>calledMethod()</code> using callback</p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod($param1)-&gt;thenReturnCallback(fn($x) =&gt; $x + 1);\n</code></pre> <p>Stub consecutive calls to <code>calledMethod()</code></p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod()-&gt;thenReturn(10)-&gt;thenReturn(20)-&gt;thenReturn(30);\n</code></pre> <p>Throw an exception when <code>calledMethod()</code> is called</p> <pre><code>$mock = Phake::mock(MyClassToMock::class);\nPhake::when($mock)-&gt;calledMethod()-&gt;thenThrow(new \\Exception('Some exception'));\n</code></pre>"},{"location":"cheat-sheet/#method-verifications-spies","title":"Method Verifications (Spies)","text":"<p>Verify that the <code>calledMethod()</code> was called once without parameters</p> <pre><code>Phake::verify($mock)-&gt;calledMethod();\n</code></pre> <p>Verify that the <code>calledMethod()</code> was called once with a specific parameter</p> <pre><code>Phake::verify($mock)-&gt;calledMethod('param');\n</code></pre> <p>Verify that the <code>calledMethod()</code> was called twice without parameters</p> <pre><code>Phake::verify($mock, Phake::times(2))-&gt;calledMethod();\n</code></pre> <p>Verify that the <code>calledMethod()</code> was called at least twice without parameters</p> <pre><code>Phake::verify($mock, Phake::atLeast(2))-&gt;calledMethod();\n</code></pre> <p>Verify that the <code>calledMethod()</code> was called at most twice without parameters</p> <pre><code>Phake::verify($mock, Phake::atMost(2))-&gt;calledMethod();\n</code></pre> <p>Verify that the <code>calledMethod()</code> was never called without parameters</p> <pre><code>Phake::verify($mock, Phake::never())-&gt;calledMethod();\n</code></pre> <p>Verify that mock did not receive any interaction</p> <pre><code>Phake::verifyNoInteraction($mock);\n</code></pre> <p>Verify that calls were made in order</p> <pre><code>Phake::inOrder(\n    Phake::verify($mock)-&gt;firstCall(),\n    Phake::verify($mock2)-&gt;secondCall(),\n    Phake::verify($mock)-&gt;yetAnOthercall()\n);\n</code></pre> <p>Capture parameters</p> <pre><code>Phake::verify($mock)-&gt;calledMethod(Phake::capture($parameter1));\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Phake 4 depends on PHP 7.1 or greater. It has no dependency on PHPUnit and should be usable with any version of PHPUnit compatible with your PHP version.</p>"},{"location":"getting-started/#composer-install","title":"Composer Install","text":"<p>Phake can be installed via Composer. You will typically want to install Phake as a development requirement. To do so you can run the command :</p> <pre><code>composer require --dev phake/phake\n</code></pre>"},{"location":"getting-started/#install-from-source","title":"Install from Source","text":"<p>You can also clone a copy of Phake from the Phake GitHub repository.</p> <pre><code>git clone https://github.com/phake/phake.git\n</code></pre> <p>Every attempt is made to keep the master branch stable and this should be usable for those that immediately need features before they get released or in the event that you enjoy the bleeding edge. Always remember, until something goes into a rc state, there is always a chance that the functionality may change. However as an early adopter that uses GitHub, you can have a chance to mold the software as it is built.</p>"},{"location":"getting-started/#have-fun-using-phake","title":"Have fun using Phake","text":"<p>Once Phake is installed you can start having fun with it. To learn how to use it we recommend you to read the full documentation but if you're in a hurry or impatient you can refer to our Cheat sheet.</p>"},{"location":"getting-started/#support","title":"Support","text":"<p>If you think you have found a bug or an issue with Phake, please feel free to open up an issue on the Phake Issue Tracker .</p>"},{"location":"doc/","title":"Introduction to Phake","text":"<p>Phake is a mocking framework for PHP. It allows for the creation of objects that mimic a real object in a predictable and controlled manner. This allows you to treat external method calls made by your system under test (SUT) as just another form of input to your SUT and output from your SUT. This is done by stubbing methods that supply indirect input into your test and by verifying parameters to methods that receive indirect output from your test.</p> <p>In true Las Vegas spirit I am implementing a new framework that allows you to easily create new card games. Most every card game at one point or another needs a dealer. In the example below I have created a new class called <code>CardGame</code> that implements the basic functionality for a card game:</p> <pre><code>class CardGame\n{\n    private DealerStrategy   $dealerStrategy;\n    private CardCollection   $deck;\n    private PlayerCollection $players;\n\n    public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)\n    {\n        $this-&gt;dealerStrategy = $dealerStrategy;\n        $this-&gt;deck = $deck;\n        $this-&gt;players = $players;\n    }\n\n    public function dealCards()\n    {\n        $this-&gt;deck-&gt;shuffle();\n        $this-&gt;dealerStrategy-&gt;deal($deck, $players);\n    }\n}\n</code></pre> <p>If I want to create a new test to ensure that <code>dealCards()</code> works properly, what do I need to test? Everything I read about testing says that I need to establish known input for my test, and then test its output. However, in this case, I don\u2019t have any parameters that are passed into <code>dealCards()</code> nor do I have any return values I can check. I could just run the <code>dealCards()</code> method and make sure I don\u2019t get any errors or exceptions, but that proves little more than my method isn\u2019t blowing up spectacularly. It is apparent that I need to ensure that what I actually assert is that the <code>shuffle()</code> and <code>deal()</code> methods are being called. If I want to continue testing this using concrete classes that already exist in my system, I could conjure up one of my implementations of <code>DealerStrategy</code>, <code>CardCollection</code> and <code>PlayerCollection</code>. All of those objects are closer to being true value objects with a testable state. I could feasibly construct instances of those objects, pass them into an instance of <code>CardGame</code>, call <code>dealCards()</code> and then assert the state of those same objects. A test doing this might look something like:</p> <pre><code>class CardGameTest1 extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealCards()\n    {\n        $dealer = new FiveCardPokerDealer();\n        $deck = new StandardDeck();\n        $player1 = new Player();\n        $player2 = new Player();\n        $player3 = new Player();\n        $player4 = new Player();\n        $players = new PlayerCollection([$player1, $player2, $player3, $player4]);\n\n        $cardGame = new CardGame($dealer, $deck, $players);\n        $cardGame-&gt;dealCards();\n\n        $this-&gt;assertEquals(5, count($player1-&gt;getCards()));\n        $this-&gt;assertEquals(5, count($player2-&gt;getCards()));\n        $this-&gt;assertEquals(5, count($player3-&gt;getCards()));\n        $this-&gt;assertEquals(5, count($player4-&gt;getCards()));\n    }\n}\n</code></pre> <p>This test isn\u2019t all that bad, it\u2019s not difficult to understand and it does make sure that cards are dealt through making sure that each player has 5 cards. There are at least two significant problems with this test however. The first problem is that there is not any isolation of the SUT which in this case is <code>dealCards()</code>. If something is broken in the <code>FiveCardPokerDealer</code> class, the <code>Player</code> class, or the <code>PlayerCollection</code> class, it will manifest itself here as a broken <code>CardGame</code> class. Thinking about how each of these classes might be implemented, one could easily make the argument that this really tests the <code>FiveCardPokerDealer</code> class much more than the <code>dealCards()</code> method. The second problem is significantly more problematic. It is perfectly feasible that I could remove the call to <code>$this-&gt;deck-&gt;shuffle()</code> in my SUT and the test I have created will still test just fine. In order to solidify my test I need to introduce logic to ensure that the deck has been shuffled. With the current mindset of using real objects in my tests I could wind up with incredibly complicated logic. I could feasibly add an identifier of some sort to <code>DealerStrategy::shuffle()</code> to mark the deck as shuffled thereby making it checkable state, however that makes my design more fragile as I would have to ensure that identifier was set probably on every implementation of <code>DealerStrategy::shuffle()</code>.</p> <p>This is the type of problem that mock frameworks solve. A mock framework such as Phake can be used to create implementations of my <code>DealerStrategy</code>, <code>CardCollection</code>, and <code>PlayerCollection</code> classes. I can then exercise my SUT. Finally, I can verify that the methods that should be called on these objects were called correctly. If this test were re-written to use Phake, it would become:</p> <pre><code>class CardGameTest2 extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealCards()\n    {\n        $dealer  = Phake::mock(DealerStrategy::class);\n        $deck    = Phake::mock(CardCollection::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $cardGame = new CardGame($dealer, $deck, $players);\n        $cardGame-&gt;dealCards();\n\n        Phake::verify($deck)-&gt;shuffle();\n        Phake::verify($dealer)-&gt;deal($deck, $players);\n    }\n}\n</code></pre> <p>There are three benefits of using mock objects that can be seen through this example. The first benefit is that the brittleness of the fixture is reduced. In our previous example you see that I have to construct a full object graph based on the dependencies of all of the classes involved. I am fortunate in the first example that there are only 4 classes involved. In real world problems and especially long lived, legacy code the object graphs can be much, much larger. When using mock objects you typically only have to worry about the direct dependencies of your SUT. Specifically, direct dependencies required to instantiate the dependencies of the class under test, the parameters passed to the method under test (direct dependencies,) and the values returned by additional method calls within the method under test (indirect dependencies.)</p> <p>The second benefit is the test is only testing the SUT. If this test fails due to a change in anything but the interfaces of the classes involved, the change would have had to been made in either the constructor of <code>CardGame</code>, or the <code>dealCards()</code> method itself. Obviously, if an interface change is made (such as removing the <code>shuffle()</code>) method, then I would have a scenario where the changed code is outside of this class. However, provided the removal of that method was intentional, I will know that this code needs to be addressed as it is depending on a method that no longer exists.</p> <p>The third benefit is that I have truer verification and assertions of the outcome of exercising my SUT. In this case for instance, I can be sure that if the call to <code>shuffle()</code> is removed, this test will fail. It also does it in a way that keeps the code necessary to assert your final state simple and concise. This makes my test overall much easier to understand and maintain. There is still one flaw with this example however. There is nothing here to ensure that <code>shuffle()</code> is called before <code>deal()</code> it is quite possible for someone to mistakenly reverse the order of these two calls. The Phake framework does have the ability to track call order to make this test even more bullet proof via the <code>Phake::inOrder()</code> method. I will go over this in more detail later.</p>"},{"location":"doc/answers/","title":"Answers","text":"<p>In all of the examples so far, the <code>thenReturn()</code> answer is being used. There are other answers that are remarkably useful writing your tests.</p>"},{"location":"doc/answers/#returning-the-object-itself","title":"Returning the object itself","text":"<p>When stubbing a method that can return the instance of the object itself (<code>$this</code>), it can be required to force the answer to be the instance of the mock. Rather than calling <code>thenReturn()</code> with the same mock variable as argument, Phake provides a cleaner way by calling the method <code>thenReturnSelf()</code>. Consider the following interface and class.</p> <pre><code>interface MyInterface\n{\n    public function foo(): ?static;\n\n    public function bar(): int;\n}\n</code></pre> <pre><code>class MyClass\n{\n    public function useFooBar(MyInterface $object): ?int\n    {\n        return $object-&gt;foo()?-&gt;bar();\n    }\n}\n</code></pre> <p>As <code>MyInterface::foo()</code> is not always returning the instance of the object calling, a unit test trying to cover <code>MyClass</code> that uses any instance of such interface would require to stub <code>static</code> as answer.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testUseFooBar(): void\n    {\n        $mock = Phake::mock(MyInterface::class);\n        Phake::when($mock)-&gt;foo()-&gt;thenReturnSelf();\n        Phake::when($mock)-&gt;bar()-&gt;thenReturn(42);\n\n        self::assertSame(42, (new MyClass())-&gt;useFooBar($mock));\n\n        $mock = Phake::mock(MyInterface::class);\n        Phake::when($mock)-&gt;foo()-&gt;thenReturn(null);\n\n        self::assertNull((new MyClass())-&gt;useFooBar($mock));\n    }\n}\n</code></pre>"},{"location":"doc/answers/#throwing-exceptions","title":"Throwing Exceptions","text":"<p>Exception handling is a common aspect of most object oriented systems that should be tested. The key to being able to test your exception handling is to be able to control the throwing of your exceptions. Phake allows this using the <code>thenThrow()</code> answer. This answer allows you to throw a specific exception from any mocked method. Below is an example of a piece of code that catches an exception from the method <code>process()</code> and then logs a message with the exception message.</p> <pre><code>class MyClass\n{\n    private Logger $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this-&gt;logger = $logger;\n    }\n\n    public function processSomeData(MyDataProcessor $processor, MyData $data)\n    {\n        try\n        {\n            $processor-&gt;process($data);\n        }\n        catch (Exception $e)\n        {\n            $this-&gt;logger-&gt;log($e-&gt;getMessage());\n        }\n    }\n}\n</code></pre> <p>In order to test this we must mock <code>process()</code> so that it throws an exception when it is called. Then we can verify that <code>log()</code> is called with the appropriate message.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testProcessSomeDataLogsExceptions()\n    {\n        $logger = Phake::mock(Logger::class);\n        $data = Phake::mock(MyData::class);\n        $processor = Phake::mock(MyDataProcessor::class);\n\n        Phake::when($processor)-&gt;process($data)-&gt;thenThrow(new Exception('My error message!'));\n\n        $sut = new MyClass($logger);\n        $sut-&gt;processSomeData($processor, $data);\n\n        //This comes from the exception we created above\n        Phake::verify($logger)-&gt;log('My error message!');\n    }\n}\n</code></pre>"},{"location":"doc/answers/#calling-the-parent","title":"Calling the Parent","text":"<p>Phake provides the ability to allow calling the actual method of an object on a method by method basis by using the <code>thenCallParent()</code> answer. This will result in the actual method being called. Consider the following class.</p> <pre><code>class MyClass\n{\n    public function foo()\n    {\n        return '42';\n    }\n}\n</code></pre> <p>The <code>thenCallParent()</code> answer can be used here to ensure that the actual method in the class is called resulting in the value 42 being returned from calls to that mocked method.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testCallingParent()\n    {\n        $mock = Phake::mock(MyClass::class);\n        Phake::when($mock)-&gt;foo()-&gt;thenCallParent();\n\n        $this-&gt;assertEquals(42, $mock-&gt;foo());\n    }\n}\n</code></pre> <p>Please avoid using this answer as much as possible especially when testing newly written code. If you find yourself requiring a class to be only partially mocked then that is a code smell for a class that is likely doing too much. An example of when this is being done is why you are testing a class that has a singular method that has a lot of side effects that you want to mock while you allow the other methods to be called as normal. In this case that method that you are desiring to mock should belong to a completely separate class. It is obvious by the very fact that you are able to mock it without needing to mock other messages that it performs a different function.</p> <p>Even though partial mocking should be avoided with new code, it is often very necessary to allow creating tests while refactoring legacy code, tests involving 3rd party code that can\u2019t be changed, or new tests of already written code that cannot yet be changed. This is precisely the reason why this answer exists and is also why it is not the default answer in Phake.</p>"},{"location":"doc/answers/#capturing-a-return-value","title":"Capturing a Return Value","text":"<p>Another tool in Phake for testing legacy code is the <code>captureReturnTo()</code> answer. This performs a function similar to argument capturing, however it instead captures what the actual method of a mock object returns to the variable passed as its parameter. Again, this should never be needed if you are testing newly written code. However I have ran across cases several times where legacy code calls protected factory methods and the result of the method call is never exposed. This answer gives you a way to access that variable to ensure that the factory was called and is operating correctly in the context of your method that is being tested.</p>"},{"location":"doc/answers/#answer-callbacks","title":"Answer Callbacks","text":"<p>While the answers provided in Phake should be able to cover most of the scenarios you will run into when using mocks in your unit tests there may occasionally be times when you need more control over what is returned from your mock methods. When this is the case, you can use a callback answer. These do generally increase the complexity of tests and you really should only use them if you won't know what you need to return until call time.</p> <p>You can specify a callback answer using the thenReturnCallback method. This argument takes a callback or a closure. The callback will be passed the same arguments as were passed to the method being stubbed. This allows you to use them to help determine the answer.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testCallback()\n    {\n        $mock = Phake::mock(MyClass::class);\n        Phake::when($mock)-&gt;foo-&gt;thenReturnCallback(function ($val) { return $val * 2; });\n\n        $this-&gt;assertEquals(42, $mock-&gt;foo(21));\n    }\n}\n</code></pre>"},{"location":"doc/answers/#custom-answers","title":"Custom Answers","text":"<p>You can also create custom answers. All answers in Phake implement the <code>Phake\\Stubber\\IAnswer</code> interface. This interface defines a single method called <code>getAnswer()</code> that can be used to return what will be returned from a call to the method being stubbed. If you need to get access to how the method you are stubbing was invoked, there is a more complex set of interfaces that can be implemented: <code>Phake\\Stubber\\Answers\\IDelegator</code> and <code>Phake\\Stubber\\IAnswerDelegate</code>.</p> <p><code>Phake\\Stubber\\Answers\\IDelegator</code> extends <code>Phake\\Stubber\\IAnswer</code> and defines an additional method called <code>processAnswer()</code> that is used to perform processing on the results of <code>getAnswer()</code> prior to passing it on to the stub\u2019s caller. <code>Phake\\Stubber\\IAnswerDelegate</code> defines an interface that allows you to create a callback that is called to generate the answer from the stub. It defines <code>getCallBack()</code> which allows you to generate a PHP callback based on the object, method, and arguments that a stub was called with. It also defines <code>getArguments()</code> which allows you to generate the arguments that will be passed to the callback based on the method name and arguments the stub was called with.</p>"},{"location":"doc/configuration/","title":"Configuration","text":"<p>There are some options you can use to configure and customize Phake. None of these options are required and Phake can always just be used straight out of the box, however some configuration options are available to provide more convenient integration with PHPUnit and ability to debug your mock objects.</p>"},{"location":"doc/configuration/#setting-the-phake-client","title":"Setting the Phake Client","text":"<p>While Phake does not have a direct dependency on PHPUnit, there is a PHPUnit specific client that improves error reporting and allows you to utilize strict mode with PHPUnit. Without using the PHPUnit client, any failed verifications will result in an errored test. Generally speaking, with PHPUnit, the error result is reserved for bad tests, not failed tests.</p> <p>The other issue you would run into when using Phake with PHPUnit without using the PHPUnit Phake client is that any test runs utilizing the --strict flag will fail when an assertion is not recorded. By default Phake does not register assertions with PHPUnit. When the PHPUnit client is used however, the assertions are recorded and --strict mode can be safely used with your tests.</p> <p>To enable the PHPUnit Phake client, you can register it in your test bootstrap.</p> <pre><code>require_once('Phake.php');\nPhake::setClient(Phake::CLIENT_PHPUNIT);\n</code></pre>"},{"location":"doc/configuration/#setting-the-mock-class-loader","title":"Setting the Mock Class Loader","text":"<p>When generating mock classes, Phake will load them into memory utilizing the PHP <code>eval()</code> function. This can make the code inside of mock classes difficult to debug or diagnose when errors occur in this code. Using the <code>Phake::setMockLoader()</code> method you can change this behavior to instead dump the generated class to a file and then require that file. This will allow for accurate and easily researchable errors when running tests. This shouldn't typically be required for most users of Phake, however if your are having errors or working on code for Phake itself it can be incredibly useful.</p> <p><code>Phake::setMockLoader()</code> accepts a single parameter of type <code>Phake\\ClassGenerator\\ILoader</code>. The default behavior is contained in the <code>Phake\\ClassGenerator\\EvalLoader</code> class. If you would instead like to dump the classes to files you can instead use the <code>Phake\\ClassGenerator\\FileLoader</code> class. The constructor accepts a single parameter containing the directory you would like to dump the classes to. The classes will be stored in files with the same name as the generated class.</p> <p>Below is an example of the code required to dump mock classes into the /tmp folder.</p> <pre><code>require_once('Phake.php');\nrequire_once('Phake/ClassGenerator/FileLoader.php');\nPhake::setMockLoader(new Phake\\ClassGenerator\\FileLoader('/tmp'));\n</code></pre>"},{"location":"doc/method-parameter-matchers/","title":"Method Parameter Matchers","text":"<p>The verification and stubbing functionality in Phake both rely heavily on parameter matching to help the system understand exactly which calls need to be verified or stubbed. Phake provides several options for setting up parameter matches.</p> <p>The most common scenario for matching parameters as you use mock objects is matching on equal variables For this reason the default matcher will ensure that the parameter you pass to the mock method is equal (essentially using the <code>==</code> notation) to the parameter passed to the actual invocation before validating the call or returning the mocked stub. So going back to the card game demonstration from the introduction. Consider the following interface:</p> <pre><code>interface DealerStrategy\n{\n    public function deal(CardCollection $deck, PlayerCollection $players);\n}\n</code></pre> <p>Here we have a <code>deal()</code> method that accepts two parameters. If you want to verify that <code>deal()</code> was called, chances are very good that you want to verify the the parameters as well. To do this is as simple as passing those parameters to the <code>deal()</code> method on the <code>Phake::verify($deal)</code> object just as you would if you were calling the actual <code>deal()</code> method itself. Here is a short albeit silly example:</p> <pre><code>// I don't have Concrete versions of CardCollection or PlayerCollection yet\n$deck = Phake::mock(CardCollection::class);\n$players = Phake::mock(PlayerCollection::class);\n\n\n$dealer = Phake::mock(DealerStrategy::class);\n\n$dealer-&gt;deal($deck, $players);\n\nPhake::verify($dealer)-&gt;deal($deck, $players);\n</code></pre> <p>In this example, if I were to have accidentally made the call to <code>deal()</code> with a property that was set to null as the first parameter then my test would fail with the following exception</p> <pre><code>Expected DealerStrategy-&gt;deal(equal to &lt;object:CardCollection&gt;, equal to &lt;object:PlayerCollection&gt;) to be called exactly 1 times, actually called 0 times.\nOther Invocations:\n  PhakeTest_MockedClass-&gt;deal(&lt;null&gt;, equal to &lt;object:PlayerCollection&gt;)\n</code></pre> <p>Determining the appropriate method to stub works in exactly the same way.</p> <p>There may be cases when it is necessary to verify or stub parameters based on something slightly more complex then basic equality. This is what we will talk about next.</p>"},{"location":"doc/method-parameter-matchers/#using-phpunit-matchers","title":"Using PHPUnit Matchers","text":"<p>Phake was developed with PHPUnit in mind. It is not dependent on PHPUnit, however if PHPUnit is your testing framework of choice there is some special integration available. Any constraints made available by the PHPUnit framework will work seamlessly inside of Phake. Here is an example of how the PHPUnit constraints  can be used:</p> <pre><code>class TestPHPUnitConstraint extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealNumberOfCards()\n    {\n        $deck = Phake::mock(CardCollection::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $dealer = Phake::mock(DealerStrategy::class);\n        $dealer-&gt;deal($deck, $players, 11);\n\n        Phake::verify($dealer)\n            -&gt;deal($deck, $players, $this-&gt;greaterThan(10));\n    }\n}\n</code></pre> <p>I have added another parameter to my <code>deal()</code> method that allows me to specify the number of cards to deal to each player. In the test above I wanted to verify that the number passed to this parameter was greater than 10.</p> <p>For a list of the constraints you have available to you through PHPUnit, I recommend reading the PHPUnit's documentation on assertions and constraints. Any constraint that can be used with <code>assertThat()</code> in PHPUnit can also be used in Phake.</p>"},{"location":"doc/method-parameter-matchers/#using-hamcrest-matchers","title":"Using Hamcrest Matchers","text":"<p>If you do not use PHPUnit, Phake also supports Hamcrest matchers . This is in-line with the Phake's design goal of being usable with any testing framework. Here is a repeat of the PHPUnit example, this time using SimpleTest and Hamcrest matchers.</p> <pre><code>class TestHamcrestMatcher extends UnitTestCase\n{\n    public function testDealNumberOfCards()\n    {\n        $deck = Phake::mock(CardCollection::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $dealer = Phake::mock(DealerStrategy::class);\n        $dealer-&gt;deal($deck, $players, 11);\n\n        Phake::verify($dealer)-&gt;deal($deck, $players, greaterThan(10));\n    }\n}\n</code></pre>"},{"location":"doc/method-parameter-matchers/#wildcard-parameters","title":"Wildcard Parameters","text":"<p>Frequently when stubbing methods, you do not really care about matching parameters. Often times matching every parameter for a stub can result in overly brittle tests. If you find yourself in this situation you can use Phake's shorthand stubbing to instruct Phake that a mock should be stubbed on any invocation. You could also use it to verify a method call regardless of parameters. This is not a very common use case but it is possible.</p> <p>To specify that a given stub or verification method should match any parameters, you call the method you are stubbing or mocking as a property of <code>Phake::when()</code> or <code>Phake::verify()</code>. The code below will mock any invocation of <code>$obj-&gt;foo()</code> regardless of parameters to return bar.</p> <pre><code>class FooTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testAddItemsToCart()\n    {\n        $obj = Phake::mock(MyObject::class);\n\n        Phake::when($obj)-&gt;foo-&gt;thenReturn('bar');\n\n        $this-&gt;assertEquals('bar', $obj-&gt;foo());\n        $this-&gt;assertEquals('bar', $obj-&gt;foo('a parameter'));\n        $this-&gt;assertEquals('bar', $obj-&gt;foo('multiple', 'parameters'));\n    }\n}\n</code></pre> <p>If you are familiar with <code>Phake::anyParameters()</code> then you will recognize that the shorthand functionality is really just short hand of <code>Phake::anyParameters()</code>.</p>"},{"location":"doc/method-parameter-matchers/#default-and-variable-parameters","title":"Default and Variable Parameters","text":"<p>Wildcards can also come in handy when stubbing or verifying methods with default parameters or variable parameters. In addition to <code>Phake::anyParameters()</code>, <code>Phake::ignoreRemaining()</code> can be used to instruct Phake to not attempt to match any further parameters.</p> <p>A good example of where this could be handy is if you are mocking or verifying a method where the first parameter is important to stubbing but maybe the remaining parameters aren't. The code below stubs a factory method where the first parameter sets an item's name, but the remaining parameters are all available as defaults.</p> <pre><code>class MyFactory\n{\n    public function createItem($name, $color = 'red', $size = 'large')\n    {\n        //...\n    }\n}\n\nclass MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testUsingItemFactory()\n    {\n        $factory = Phake::mock(MyFactory::class);\n\n        $factory-&gt;createItem('Item1', 'blue', 'small');\n\n        //Verification below will succeed\n        Phake::verify($factory)-&gt;createItem('Item1', Phake::ignoreRemaining());\n    }\n}\n</code></pre>"},{"location":"doc/method-parameter-matchers/#parameter-capturing","title":"Parameter Capturing","text":"<p>As you can see there are a variety of methods for verifying that the appropriate parameters are being passed to methods. However, there may be times when the prebuilt constraints and matchers simply do not fit your needs. Perhaps there is method that accepts a complex object where only certain components of the object need to be validated. Parameter capturing will allow you to store the parameter that was used to call your method so that it can be used in assertions later on.</p> <p>Consider the following example where I have defined a <code>getNumberOfCards()</code> method on the <code>CardCollection</code> interface.</p> <pre><code>interface CardCollection\n{\n    public function getNumberOfCards();\n}\n</code></pre> <p>I want to create new functionality for a my poker dealer strategy that will check to make sure we are playing with a full deck of 52 cards when the <code>deal()</code> call is made. It would be rather cumbersome to create a copy of a <code>CardCollection</code> implementation that I could be sure would match in an equals scenario. Such a test would look something like this.</p> <p>Please note, I do not generally advocate this type of design. I prefer dependency injection to instantiation. So please remember, this is not an example of clean design, simply an example of what you can do with argument capturing.</p> <pre><code>class MyPokerGameTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealCards()\n    {\n        $dealer = Phake::mock(MyPokerDealer::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $cardGame = new MyPokerGame($dealer, $players);\n\n        Phake::verify($dealer)-&gt;deal(Phake::capture($deck), $players);\n\n        $this-&gt;assertEquals(52, $deck-&gt;getNumberOfCards());\n    }\n}\n</code></pre> <p>You can also capture parameters if they meet a certain condition. For instance, if someone mistakenly passed an array as the first parameter to the <code>deal()</code> method then PHPUnit would fatal error out. This can be protected against by using the the <code>Phake::capture()-&gt;when()</code> method. The <code>when()</code> method accepts the same constraints that <code>Phake::verify()</code> accepts. Here is how you could leverage that functionality to bulletproof your captures a little bit.</p> <pre><code>class MyBetterPokerGameTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealCards()\n    {\n        $dealer = Phake::mock(MyPokerDealer::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $cardGame = new MyPokerGame($dealer, $players);\n\n        Phake::verify($dealer)-&gt;deal(\n            Phake::capture($deck)\n                -&gt;when($this-&gt;isInstanceOf(CardCollection::class)),\n            $players\n        );\n\n        $this-&gt;assertEquals(52, $deck-&gt;getNumberOfCards());\n    }\n}\n</code></pre> <p>This could also be done by using PHPUnit's assertions later on with the captured parameter, however this also has a side effect of better localizing your error. Here is the error you would see if the above test failed.</p> <pre><code>Exception: Expected MyPokerDealer-&gt;deal(&lt;captured parameter&gt;,\nequal to &lt;object:PlayerCollection&gt;) to be called exactly 1\ntimes, actually called 0 times.\nOther Invocations:\n  PhakeTest_MockedClass-&gt;deal(&lt;array&gt;,\n&lt;object:PlayerCollection&gt;)\n</code></pre> <p>It should be noted that while it is possible to use argument capturing for stubbing with <code>Phake::when()</code> I would discourage it. When stubbing a method, you should only be concerned about making sure an expected value is returned. Argument capturing in no way helps with that goal. In the worst case scenario, you will have some incredibly difficult test failures to diagnose.</p> <p>Beginning in Phake 2.1 you can also capture all values for a given parameter for every matching invocation. For instance imagine if you have a method <code>$foo-&gt;process($eventManager)</code> that should send a series of events.</p> <pre><code>class Foo\n{\n    // ...\n    public function process(Request $request, EventManager $eventManager)\n    {\n       $eventManager-&gt;fire(new PreProcessEvent($request));\n       // ... do stuff\n       $eventManager-&gt;fire(new PostProcessEvent($request, $result));\n    }\n}\n</code></pre> <p>If you wanted to verify different aspects of the <code>$eventManager-&gt;fire()</code> calls this would have been very difficult and brittle using standard argument captors. There is now a new method <code>Phake::captureAll()</code> that can be used to capture all otherwise matching invocations of method. The variable passed to <code>Phake::captureAll()</code> will be set to an array containing all of the values used for that parameter. So with this function the following test can be written.</p> <pre><code>class FooTest\n{\n    public function testProcess()\n    {\n        $foo = new Foo();\n        $request = Phake::mock(Request::class);\n        $eventManager = Phake::mock(EventManager::class);\n\n        $foo-&gt;process($request, $eventManager);\n\n        Phake::verify($eventManager, Phake::atLeast(1))-&gt;fire(Phake::captureAll($events));\n\n        $this-&gt;assertInstanceOf(PreProcessEvent::class, $events[0]);\n        $this-&gt;assertEquals($request, $events[0]-&gt;getRequest());\n\n        $this-&gt;assertInstanceOf(PostProcessEvent::class, $events[1]);\n        $this-&gt;assertEquals($request, $events[1]-&gt;getRequest());\n    }\n}\n</code></pre>"},{"location":"doc/method-parameter-matchers/#custom-parameter-matchers","title":"Custom Parameter Matchers","text":"<p>An alternative to using argument capturing is creating custom matchers. All parameter matchers implement the interface <code>Phake\\Matchers\\IArgumentMatcher</code>. You can create custom implementations of this interface. This is especially useful if you find yourself using a similar capturing pattern over and over again. If I were to rewriting the test above using a customer argument matcher it would look something like this.</p> <pre><code>class FiftyTwoCardDeckMatcher implements Phake\\Matchers\\IArgumentMatcher\n{\n    public function matches(&amp;$argument)\n    {\n        return ($argument instanceof CardCollection\n            &amp;&amp; $argument-&gt;getNumberOfCards() == 52);\n    }\n\n    public function __toString()\n    {\n        return '&lt;object:CardCollection with 52 cards&gt;';\n    }\n}\n\nclass MyBestPokerGameTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testDealCards()\n    {\n        $dealer = Phake::mock(MyPokerDealer::class);\n        $players = Phake::mock(PlayerCollection::class);\n\n        $cardGame = new MyPokerGame($dealer, $players);\n\n        Phake::verify($dealer)-&gt;deal(new FiftyTwoCardDeckMatcher(), $players);\n    }\n}\n</code></pre>"},{"location":"doc/method-verification/","title":"Method Verification","text":"<p>The <code>Phake::verify()</code> method is used to assert that method calls have been made on a mock object that you can create with <code>Phake::mock()</code>. <code>Phake::verify()</code> accepts the mock object you want to verify calls against. Mock objects in Phake can almost be viewed as a tape recorder. Any time the code you are testing calls a method on an object you create with <code>Phake::mock()</code> it is going to record the method that you called along with all of the parameters used to call that method. Then <code>Phake::verify()</code> will look at that recording and allow you to assert whether or not a certain call was made.</p> <pre><code>class PhakeTest1 extends PHPUnit\\Framework\\TestCase\n{\n    public function testBasicVerify()\n    {\n        $mock = Phake::mock(MyClass::class);\n\n        $mock-&gt;foo();\n\n        Phake::verify($mock)-&gt;foo();\n    }\n}\n</code></pre> <p>The <code>Phake::verify()</code> call here, verifies that the method <code>foo()</code> has been called once (and only once) with no parameters on the object <code>$mock</code>. A very important thing to note here that is a departure from most (if not all) other PHP mocking frameworks is that you want to verify the method call AFTER the method call takes place. Other mocking frameworks such as the one built into PHPUnit depend on you setting the expectations of what will get called prior to running the system under test.</p> <p>Phake strives to allow you to follow the four phases of a unit test as laid out in xUnit Test Patterns: setup, exercise, verify, and teardown. The setup phase of a test using Phake for mocking will now include calls to <code>Phake::mock()</code> for each class you want to mock. The exercise portion of your code will remain the same. The verify section of your code will include calls to <code>Phake::verify()</code>. The exercise and teardown phases will remain unchanged.</p>"},{"location":"doc/method-verification/#verifying-method-parameters","title":"Verifying Method Parameters","text":"<p>Verifying method parameters using Phake is very simple yet can be very flexible. There are a wealth of options for matching parameters that are discussed later on in Method Parameter Matchers.</p>"},{"location":"doc/method-verification/#verifying-multiple-invocations","title":"Verifying Multiple Invocations","text":"<p>A common need for mock objects is the ability to have variable multiple invocations on that object. Phake allows you to use <code>Phake::verify()</code> multiple times on the same object. A notable difference between Phake and PHPUnit\u2019s mocking framework is the ability to mock multiple invocations of the same method with no regard for call sequences. The PHPUnit mocking test below would fail for this reason.</p> <pre><code>class MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testPHPUnitMock()\n    {\n        $mock = $this-&gt;getMock(PhakeTest_MockedClass::class);\n\n        $mock-&gt;expects($this-&gt;once())-&gt;method('fooWithArgument')\n                -&gt;with('foo');\n\n        $mock-&gt;expects($this-&gt;once())-&gt;method('fooWithArgument')\n                -&gt;with('bar');\n\n        $mock-&gt;fooWithArgument('foo');\n        $mock-&gt;fooWithArgument('bar');\n    }\n}\n</code></pre> <p>The reason this test fails is because by default PHPUnit only allows a single expectation per method. The way you can fix this is by using the <code>at()</code> matcher. This allows you to specify the index of the invocation you want to match again. So to make the test above work you would have to change it.</p> <pre><code>class MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testPHPUnitMock()\n    {\n        $mock = $this-&gt;getMock(PhakeTest_MockedClass::class);\n\n        //NOTICE this is now at() instead of once()\n        $mock-&gt;expects($this-&gt;at(0))-&gt;method('fooWithArgument')\n                -&gt;with('foo');\n\n        //NOTICE this is now at() instead of once()\n        $mock-&gt;expects($this-&gt;at(1))-&gt;method('fooWithArgument')\n                -&gt;with('bar');\n\n        $mock-&gt;fooWithArgument('foo');\n        $mock-&gt;fooWithArgument('bar');\n    }\n}\n</code></pre> <p>This test will now run as expected. There is still one small problem however and that is that you are now testing not just the invocations but also the order of invocations. Many times the order in which two calls are made really do not matter. If swapping the order of two method calls will not break your application then there is no reason to enforce that code structure through a unit test. Unfortunately, you cannot have multiple invocations of a method in PHPUnit without enforcing call order. In Phake these two notions of call order and multiple invocations are kept completely distinct. Here is the same test written using Phake.</p> <pre><code>class MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testPHPUnitMock()\n    {\n        $mock = Phake::mock(PhakeTest_MockedClass::class);\n\n        $mock-&gt;fooWithArgument('foo');\n        $mock-&gt;fooWithArgument('bar');\n\n        Phake::verify($mock)-&gt;fooWithArgument('foo');\n        Phake::verify($mock)-&gt;fooWithArgument('bar');\n    }\n}\n</code></pre> <p>You can switch the calls around in this example as much as you like and the test will still pass. You can mock as many different invocations of the same method as you need.</p> <p>If you would like to verify the exact same parameters are used on a method multiple times (or they all match the same constraints multiple times) then you can use the verification mode parameter of <code>Phake::verify()</code>. The second parameter to <code>Phake::verify()</code> allows you to specify how many times you expect that method to be called with matching parameters. If no value is specified then the default of one is used. The other options are:</p> <ul> <li><code>Phake::times($n)</code> \u2013 Where <code>$n</code> equals the exact number of times you expect the method to be called.</li> <li><code>Phake::atLeast($n)</code> \u2013 Where <code>$n</code> is the minimum number of times you expect the method to be called.</li> <li><code>Phake::atMost($n)</code> \u2013 Where <code>$n</code> is the most number of times you would expect the method to be called.</li> <li><code>Phake::never()</code> - Same as calling <code>Phake::times(0)</code>.</li> </ul> <p>Here is an example of this in action.</p> <pre><code>class MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testPHPUnitMock()\n    {\n        $mock = Phake::mock(PhakeTest_MockedClass::class);\n\n        $mock-&gt;fooWithArgument('foo');\n        $mock-&gt;fooWithArgument('foo');\n\n        Phake::verify($mock, Phake::times(2))-&gt;fooWithArgument('foo');\n    }\n}\n</code></pre>"},{"location":"doc/method-verification/#verifying-calls-happen-in-a-particular-order","title":"Verifying Calls Happen in a Particular Order","text":"<p>Sometimes the desired behavior is that you verify calls happen in a particular order. Say there is a functional reason for the two variants of <code>fooWithArgument()</code> to be called in the order of the original test. You can utilize <code>Phake::inOrder()</code> to ensure the order of your call invocations. <code>Phake::inOrder()</code> takes one or more arguments and errors out in the event that one of the verified calls was invoked out of order. The calls don\u2019t have to be in exact sequential order, there can be other calls in between, it just ensures the specified calls themselves are called in order relative to each other. Below is an example Phake test that behaves similarly to the PHPUnit test that utilized <code>at()</code>.</p> <pre><code>class MyTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testPHPUnitMock()\n    {\n        $mock = Phake::mock(PhakeTest_MockedClass::class);\n\n        $mock-&gt;fooWithArgument('foo');\n        $mock-&gt;fooWithArgument('bar');\n\n        Phake::inOrder(\n            Phake::verify($mock)-&gt;fooWithArgument('foo'),\n            Phake::verify($mock)-&gt;fooWithArgument('bar')\n        );\n    }\n}\n</code></pre>"},{"location":"doc/method-verification/#verifying-no-interaction-with-a-mock-so-far","title":"Verifying No Interaction with a Mock so Far","text":"<p>Occasionally you may want to ensure that no interactions have occurred with a mock object. This can be done by passing your mock object to <code>Phake::verifyNoInteraction($mock)</code>. This will not prevent further interaction with your mock, it will simply tell you whether or not any interaction up to that point has happened. You can pass multiple arguments to this method to verify no interaction with multiple mock objects.</p>"},{"location":"doc/method-verification/#verifying-no-further-interaction-with-a-mock","title":"Verifying No Further Interaction with a Mock","text":"<p>There is a similar method to prevent any future interaction with a mock. This can be done by passing a mock object to <code>Phake::verifyNoFurtherInteraction($mock)</code>. You can pass multiple arguments to this method to verify no further interaction occurs with multiple mock objects.</p>"},{"location":"doc/method-verification/#verifying-no-unverified-interaction-with-a-mock","title":"Verifying No Unverified Interaction with a Mock","text":"<p>By default any unverified calls to a mock are ignored. That is to say, if a call is made to <code>$mock-&gt;foo()</code> but <code>Phake::verify($mock)-&gt;foo()</code> is never used, then no failures are thrown. If you want to be stricter and ensure that all calls have been verified you can call <code>Phake::verifyNoOtherInteractions($mock)</code> at the end of your test. This will check and make sure that all calls to your mock have been verified by one or more calls to Phake verify. This method should only be used in those cases where you can clearly say that it is important that your test knows about all calls on a particular object. One useful case for instance could be in testing a method that returns a filtered array.</p> <pre><code>class FilterTest {\n    public function testFilteredList()\n    {\n        $filter = new MyFilter();\n        $list = Phake::Mock(MyList::class);\n\n        $filter-&gt;addEvenToList([ 1, 2, 3, 4, 5 ], $list);\n\n        Phake::verify($list)-&gt;push(2);\n        Phake::verify($list)-&gt;push(4);\n\n        Phake::verifyNoOtherInteractions($list);\n    }\n}\n</code></pre> <p>Without <code>Phake::verifyNoOtherInteractions($list)</code> you would have to add additional verifications that <code>$list-&gt;push()</code> was not called for the odd values in the list. This method should be used only when necessary. Using it in every test is an anti-pattern that will lead to brittle tests.</p>"},{"location":"doc/method-verification/#verifying-magic-methods","title":"Verifying Magic Methods","text":"<p>Most magic methods can be verified using the method name just like you would any other method. The one exception to this is the <code>__call()</code> method. This method is overwritten on each mock already to allow for the fluent api that Phake utilizes. If you want to verify a particular invocation of <code>__call()</code> you can verify the actual method call by mocking the method passed in as the first parameter.</p> <p>Consider the following class.</p> <pre><code>class MagicClass\n{\n    public function __call($method, $args)\n    {\n        return '__call';\n    }\n}\n</code></pre> <p>You could mock an invocation of the <code>__call()</code> method through a userspace call to <code>magicCall()</code> with the following code.</p> <pre><code>class MagicClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testMagicCall()\n    {\n        $mock = Phake::mock(MagicClass::class);\n\n        $mock-&gt;magicCall();\n\n        Phake::verify($mock)-&gt;magicCall();\n    }\n}\n</code></pre> <p>If for any reason you need to explicitly verify calls to <code>__call()</code> then you can use <code>Phake::verifyCallMethodWith()</code>.</p> <pre><code>class MagicClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testMagicCall()\n    {\n        $mock = Phake::mock(MagicClass::class);\n\n        $mock-&gt;magicCall(42);\n\n        Phake::verifyCallMethodWith('magicCall', [ 42 ])-&gt;isCalledOn($mock);\n    }\n}\n</code></pre>"},{"location":"doc/mocking-statics/","title":"Mocking Static Methods","text":"<p>Phake can be used to verify as well as stub polymorphic calls to static methods. It is important to note that you cannot verify or stub all static calls. In order for Phake to record or stub a method call, it needs to intercept the call so that it can record it. Consider the following class</p> <pre><code>class StaticCaller\n{\n    public function callStaticMethod()\n    {\n        Foo::staticMethod();\n    }\n}\n</code></pre> <p>You will not be able to stub or verify the call to <code>Foo::staticMethod()</code> because the call was made directly on the class. This prevents Phake from seeing that the call was made. However, say you have an abstract class that has an abstract static method.</p> <pre><code>abstract class StaticFactory\n{\n    protected static function factory()\n    {\n        // ...\n    }\n\n    public static function getInstance()\n    {\n        return static::factory();\n    }\n}\n</code></pre> <p>In this case, because the <code>static::</code> keyword will cause the called class to be determined at runtime, you will be able to verify and stub calls to <code>StaticFactory::factory()</code>. It is important to note that if <code>self::factory()</code> was called then stubs and verifications would not work, because again the class is determined at compile time with the self:: keyword. The key thing to remember with testing statics using Phake is that you can only test statics that leverage Late Static Binding.</p> <p>The key to testing static methods using Phake is that you need to create a \"seam\" for your static methods. If you are not familiar with that term, a seam is a location where Phake is able to override and intercept calls to your code. The typical seem for Phake is a parameter that allows you to pass your object. Typically you would pass a real object, however during testing you pass in a mock object created by Phake. This is taking advantage of an instance seam.</p> <p>Thankfully in php now you can do something along the lines of <code>$myVar::myStatic()</code> where if <code>$myVar</code> is a string it resolves as you would think for a static method. The useful piece though is that if <code>$myVar</code> is an object, it will resolve that object down to the class name and use that for the static.</p> <p>So, the general idea here is that you can take code that is in class Foo:</p> <pre><code>class Foo\n{\n    public function doSomething()\n    {\n        // ... code that does stuff ...\n        Logger::logData();\n    }\n}\n</code></pre> <p>which does not provide a seam for mocking <code>Logger::logData()</code> and provide that seem by changing it to:</p> <pre><code>class Foo\n{\n    public $logger = 'Logger';\n    public function doSomething()\n    {\n        // ... code that does stuff ...\n        $logger = $this-&gt;logger;\n        $logger::logData($data);\n    }\n}\n</code></pre> <p>Now you can mock logData as follows:</p> <pre><code>class FooTest\n{\n    public function testDoSomething()\n    {\n        $foo = new Foo();\n        $foo-&gt;logger = Phake::mock(Logger::class);\n        $foo-&gt;doSomething();\n        Phake::verifyStatic($foo-&gt;logger)-&gt;logData(Phake::anyParameters());\n    }\n}\n</code></pre> <p>Phake has alternative methods to handle interacting with static methods on your mock class. <code>Phake::mock()</code> is still used to create the mock class, but the remaining interactions with static methods use more specialized methods. The table below shows the Phake methods that have a separate counterpart for interacting with static calls.</p> Instance Method Static Method <code>Phake::when()</code> <code>Phake::whenStatic()</code> <code>Phake::verify()</code> <code>Phake::verifyStatic()</code> <code>Phake::verifyCallMethodWith()</code> <code>Phake::verifyStaticCallMethodWith()</code> <code>Phake::whenCallMethodWith()</code> <code>Phake::whenStaticCallMethodWith()</code> <code>Phake::reset()</code> <code>Phake::resetStatic()</code> <p>If you are using Phake to stub or verify static methods then you should call <code>Phake::resetStaticInfo()</code> in the the <code>tearDown()</code> method. This is necessary to reset the stubs and call recorder for the static calls in the event that the mock class gets re-used.</p>"},{"location":"doc/mocks/","title":"Creating Mocks","text":"<p>The <code>Phake::mock()</code> method is how you create new test doubles in Phake. You pass in the class name of what you would like to mock.</p> <pre><code>$mock = Phake::mock(ClassToMock::class);\n</code></pre> <p>The <code>$mock</code> variable is now an instance of a generated class that inherits from <code>ClassToMock</code> with hooks that allow you to force functions to return known values. By default, all methods on a mock object will return the type specified in the return type or null. This behavior can be overridden on a per method and even per parameter basis. This will be covered in depth in Method Stubbing.</p> <p>The mock  will also record all calls made to this class so that you can later verify that specific methods were called with the proper parameters. This will be covered in depth in Method Verification.</p> <p>In addition to classes you can also mock interfaces directly. This is done in much the same way as a class name, you simply pass the interface name as the first parameter to <code>Phake::mock()</code>.</p> <pre><code>$mock = Phake::mock(InterfaceToMock::class);\n</code></pre> <p>You can also pass an array of interface names to <code>Phake::mock()</code> that also contains up to 1 class name. This allows for easier mocking of a dependency that is required to implement multiple interfaces.</p> <pre><code>$mock = Phake::mock([ Interface1::class, Interface2::class ]);\n</code></pre>"},{"location":"doc/mocks/#partial-mocks","title":"Partial Mocks","text":"<p>When testing legacy code, you may find that a better default behavior for the methods is to actually call the original method. This can be accomplished by stubbing each of the methods to return <code>thenCallParent()</code>. You can learn more about this in Calling the Parent.</p> <p>While this is certainly possible, you may find it easier to just use a partial mock in Phake. Phake partial mocks also allow you to call the actual constructor of the class being mocked. They are created using <code>Phake::partialMock()</code>. Like <code>Phake::mock()</code>, the first parameter is the name of the class that you are mocking. However, you can pass additional parameters that will then be passed as the respective parameters to that class\u2019 constructor. The other notable feature of a partial mock in Phake is that its default answer is to pass the call through to the parent as if you were using <code>thenCallParent()</code>.</p> <p>Consider the following class that has a method that simply returns the value passed into the constructor.</p> <pre><code>class MyClass\n{\n    private $value;\n\n    public __construct($value)\n    {\n        $this-&gt;value = $value;\n    }\n\n    public function foo()\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> <p>Using <code>Phake::partialMock()</code> you can instantiate a mock object that will allow this object to function as designed while still allowing verification as well as selective stubbing of certain calls. Below is an example that shows the usage of <code>Phake::partialMock()</code>.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testCallingParent()\n    {\n        $mock = Phake::partialMock(MyClass::class, 42);\n\n        $this-&gt;assertEquals(42, $mock-&gt;foo());\n    }\n}\n</code></pre> <p>Again, partial mocks should not be used when you are testing new code. If you find yourself using them be sure to inspect your design to make sure that the class you are creating a partial mock for is not doing too much.</p>"},{"location":"doc/mocks/#calling-private-and-protected-methods-on-mocks","title":"Calling Private and Protected Methods on Mocks","text":"<p>It is possible to invoke protected and private methods on your mocks using Phake. When you mock a class, the mocked version will retain the same visibility on each of its functions as you would have had on your original class. However, using <code>Phake::makeVisible()</code> and <code>Phake::makeStaticsVisible()</code> you can allow direct invocation of instance methods and static methods accordingly. Both of these methods accept a mock object as its only parameter and returns a proxy class that you can invoke the methods on. Method calls on these proxies will still return whatever value was previously stubbed for that method call. So if you intend on the original method being called and you aren't using Partial Mocks, then you can just enable calling the parent for that method call using the <code>thenCallParent()</code> answer. This is all discussed in greater depth in Method Stubbing and Answers.</p> <pre><code>class MyClass\n{\n    private function foo()\n    {\n    }\n\n    private static function bar()\n    {\n    }\n}\n</code></pre> <p>Given the class above, you can invoke both private methods with the code below.</p> <pre><code>$mock = Phake::mock(MyClass::class);\n\nPhake::makeVisible($mock)-&gt;foo();\n\nPhake::makeStaticsVisible($mock)-&gt;bar();\n</code></pre> <p>As you can see above when using the static variant you still call the method as though it were an instance method. The other thing to take note of is that there is no modification done on $mock itself. If you use <code>Phake::makeVisible()</code> you will only be able to make those private and protected calls off of the return of that method itself.</p> <p>The best use case for this feature of Phake is if you have private or protected calls that are nested deep inside of public methods. Generally speaking you would always just test from your class's public interface. However these large legacy classes often require a significant amount of setup within fixtures to allow for calling those private and protected methods. If you are only intending on refactoring the private and protected method then using <code>Phake::makeVisible()</code> removes the need for these complex fixtures.</p> <p>Consider this really poor object oriented code. The <code>cleanRowContent()</code> function does some basic text processing such as stripping html tags, cleaning up links, etc. It turns out that the original version of this method is written in a very unperformant manner and I have been tasked with rewriting it.</p> <pre><code>class MyReallyTerribleOldClass\n{\n    public function __construct(Database $db)\n    {\n        //...\n    }\n\n    public function doWayTooMuch($data)\n    {\n        $result = $this-&gt;db-&gt;query($this-&gt;getQueryForData($data))\n\n        $rows = array();\n        while ($row = $this-&gt;db-&gt;fetch($result))\n        {\n            $rows[] = $this-&gt;cleanRowContent($row);\n        }\n\n        return $rows;\n    }\n\n    private function cleanRowContent($row)\n    {\n        //...\n    }\n\n    private function getQueryForData($data)\n    {\n        //...\n    }\n}\n</code></pre> <p>If I was about to make changes to <code>cleanRowContent</code> and wanted to make sure I didn't break previous functionality, in order to do so with the traditional fixture I would have to write a test similar to the following:</p> <pre><code>class Test extends PHPUnit\\Framework\\TestCase\n{\n    public function testProcessRow()\n    {\n        $dbRow = [ 'id' =&gt; '1', 'content' =&gt; 'Text to be processed with &lt;b&gt;tags stripped&lt;/b&gt;' ];\n        $expectedValue = [ [ 'id' =&gt; 1', 'content' =&gt; 'Text to be processed with tags stripped' ] ];\n\n        $db = Phake::mock(Database::class);\n        $result = Phake::mock(DatabaseResult::class);\n        $oldClass = new MyReallyTerribleOldClass($db);\n\n        Phake::when($db)-&gt;query-&gt;thenReturn($result);\n\n        Phake::when($db)-&gt;fetch-&gt;thenReturn($dbRow)-&gt;thenReturn(null);\n\n        $data = $oldClass-&gt;doWayTooMuch(array());\n\n        $this-&gt;assertEquals($expectedValue, $data);\n    }\n}\n</code></pre> <p>Using test helpers or PHPUnit data providers I could reuse this test to make sure I fully cover the various logic paths and use cases for the <code>cleanRowContent()</code>. However this test is doing alot of work to just set up this scenario. Whenever your test is hitting code not relevant to your test in increases the test's fragility. Here is how you could test the same code using <code>Phake::makeVisible()</code>.</p> <pre><code>class Test extends PHPUnit\\Framework\\TestCase\n{\n    public function testProcessRow()\n    {\n        $dbRow = [ 'id' =&gt; '1', 'content' =&gt; 'Text to be processed with &lt;b&gt;tags stripped&lt;/b&gt;' ];\n        $expectedValue = [ [ 'id' =&gt; 1', 'content' =&gt; 'Text to be processed with tags stripped' ] ];\n\n        $oldClass = new Phake::partialMock(MyReallyTerribleOldClass::class);\n\n        $data = Phake::makeVisible($oldClass)-&gt;cleanRowContent($dbRow);\n        $this-&gt;assertEquals($expectedValue, $data);\n    }\n}\n</code></pre> <p>As you can see the test is significantly simpler. One final note, if you find yourself using this strategy on newly written code, it could be a code smell indicitive of a class or public method doing too much. It is very reasonable to argue that in my example, the <code>cleanRowContent()</code> method should be a class in and of itself or possibly a method on a string manipulation type of class that my class then calls out to. This is a better design and also a much easier to test design.</p>"},{"location":"doc/stubbing/","title":"Method Stubbing","text":"<p>The <code>Phake::when()</code> method is used to stub methods in Phake. As discussed in the introduction, stubbing allows an object method to be forced to return a particular value given a set of parameters. Similarly to <code>Phake::verify()</code>, <code>Phake::when()</code> accepts a mock object generated from <code>Phake::mock()</code> as its first parameter.</p> <p>Imagine I was in the process of building the next great online shopping cart. The first thing any good shopping cart allows is to be able to add items. The most important thing I want to know from the shopping cart is how much money in merchandise is in there. So, I need to make myself a <code>ShoppingCart</code> class. I also am going to need some class to define my items. I am more worried about the money right now and because of that I am keenly aware that any item in a shopping cart is going to have a price. So I will just create an interface to represent those items called Item. Now take a minute to marvel at the creativity of those names. Great, now check out the initial definitions for my objects.</p> <pre><code>/**\n * An item that is going to make me rich.\n */\ninterface Item\n{\n    public function getPrice()\n}\n\n/**\n * A customer's cart that will contain items that are going to make me rich.\n */\nclass ShoppingCart\n{\n    private array $items = [];\n\n    /**\n     * Adds an item to the customer's order\n     */\n    public function addItem(Item $item): void\n    {\n        $this-&gt;items[] = $item;\n    }\n\n    /**\n     * Returns the current sub total of the customer's order\n     */\n    public function getSubTotal()\n    {\n    }\n}\n</code></pre> <p>So, I am furiously coding away at this fantastic new <code>ShoppingCart</code> class when I realize, I am doing it wrong! You see, a few years ago I went to this conference with a bunch of other geeky people to talk about how to make quality software. I am supposed to be writing unit tests. Here I am, a solid thirteen lines (not counting comments) of code into my awe inspiring new software and I haven't written a single test. I tell myself, \"There's no better time to change than right now!\" So I decide to start testing. After looking at the options I decide PHPUnit with this sweet new mock library called Phake is the way to go.</p> <p>My first test is going to be for the currently unimplemented <code>ShoppingCart::getSubTotal()</code> method. I already have a pretty good idea of what this function is going to need to do. It will need to look at all of the items in the cart, retrieve their price, add it all together and return the result. So, in my test I know I am going to need a fixture that sets up a shopping cart with a few items added. Then I am going to need a test that calls <code>ShoppingCart::getSubTotal()</code> and asserts that it returns a value equal to the price of the items I added to the cart. One catch though, I don't have any concrete instances of an <code>Item</code>. I wasn't even planning on doing any of that until tomorrow. I really want to just focus on the <code>ShoppingCart</code> class. Never fear, this is why I decided to use Phake. I remember reading about how it will allow me to quickly create instance of my classes and interfaces that I can set up stubs for so that method calls return predictable values. This project is all coming together and I am really excited.</p> <pre><code>class ShoppingCartTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testGetSub()\n    {\n        $item1 = Phake::mock(Item::class);\n        $item2 = Phake::mock(Item::class);\n        $item3 = Phake::mock(Item::class);\n\n        Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);\n        Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(200);\n        Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(300);\n\n        $shoppingCart = new ShoppingCart();\n        $shoppingCart-&gt;addItem($item1);\n        $shoppingCart-&gt;addItem($item2);\n        $shoppingCart-&gt;addItem($item3);\n\n        $this-&gt;assertEquals(600, $shoppingCart-&gt;getSubTotal());\n    }\n}\n</code></pre> <p>My test here shows a very basic use of Phake for creating method stubs. I am creating three different mock implementations of the <code>Item</code> class. Then for each of those item classes, I am creating a stub using <code>Phake::when()</code> that will return 100, 200, and 300 respectively. I know my method that I am getting ready to implement will need to call those methods in order to calculate the total cost of the order.</p> <p>My test is written so now it is time to see how it fails. I run it with phpunit and see the output below</p> <pre><code>$ phpunit ExampleTests/ShoppingCartTest.php\nPHPUnit 9.5.4 by Sebastian Bergmann and contributors.\n\nF                                                                   1 / 1 (100%)\n\nTime: 00:00.012, Memory: 4.00 MB\n\nThere was 1 failure:\n\n1) ShoppingCartTest::testGetSub\nFailed asserting that null matches expected 600.\n\n/home/mikel/Documents/Projects/Phake/tests/ShoppingCartTest.php:69\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1.\n</code></pre> <p>Now that I have a working (and I by working I mean breaking!) test it is time to look at the code necessary to make the test pass.</p> <pre><code>class ShoppingCart\n{\n    // I am cutting out the already seen code.\n    // If you want to see it again look at the previous examples!\n\n    /**\n     * Returns the current sub total of the customer's order\n     */\n    public function getSubTotal()\n    {\n        $total = 0;\n\n        foreach ($this-&gt;items as $item)\n        {\n            $total += $item-&gt;getPrice();\n        }\n\n        return $total;\n    }\n}\n</code></pre> <p>The code here is pretty simple. I am just iterating over the <code>ShoppingCart::$item</code> property, calling the <code>Item::getPrice()</code> method, and adding them all together. Now when I run phpunit, the tests were successful and I am getting off to a great start with my shopping cart.</p> <pre><code>$ phpunit ExampleTests/ShoppingCartTest.php\nPHPUnit 9.5.4 by Sebastian Bergmann and contributors.\n\n.                                                                   1 / 1 (100%)\n\nTime: 00:00.011, Memory: 4.00 MB\n\nOK (1 test, 1 assertion)\n</code></pre> <p>So, what is Phake doing here? Phake is providing us a predictable implementation of the <code>Item::getPrice()</code> method that we can use in our test. It helps me to ensure the when my test breaks I know exactly where it is breaking. I will not have to be worried that a bad implementation of <code>Item::getPrice()</code> is breaking my tests.</p>"},{"location":"doc/stubbing/#how-phakewhen-works","title":"How <code>Phake::when()</code> Works","text":"<p>Internally Phake is doing quite a bit when this test runs. The three calls to <code>Phake::mock()</code> are creating three new classes that in this case each implement the <code>Item</code> interface. These new classes each define implementations of any method defined in the <code>Item</code> interface. If <code>Item</code> extended another interface, implementations of all of that parent's defined methods would be created as well. Each method being implemented in these new classes does a few different things. The first thing that it does is record the fact that the method was called and stores the parameters that were used to call it. The next significant thing it does is looks at the stub map for that mock object. The stub map is a map that associates answers to method matchers. An answer is what a mocked object will return when it is called. By default, a call to a mock object returns a static answer of <code>NULL</code>. We will discuss answers more in Answers. A method matcher has two parts. The first is the method name. The second is an array of arguments. The array of arguments will then contain various constraints that are applied to each argument to see if a given argument will match. The most common constraint is an equality constraint that will match loosely along the same lines as the double equals sign in PHP. We will talk about matchers more in Method Parameter Matchers.</p> <p>When each mock object is initially created, its stub map will be empty. This means that any call to a method on a mock object is going to return a default answer of <code>NULL</code>. If you want your mock object's methods to return something else you must add answers to the stub map. The <code>Phake::when()</code> method allows you to map an answer to a method matcher for a given mock object. The mock object you want to add the mapping to is passed as the first parameter to <code>Phake::when()</code>. The <code>Phake::when()</code> method will then return a proxy that can be used add answers to your mock object's stub map. The answers are added by making method calls on the proxy just as you would on the mock object you are proxying. In the first example above you saw a call to <code>Phake::when($this-&gt;item1)-&gt;getPrice()</code>. The <code>getPrice()</code> call here was telling Phake that I am about to define a new answer that will be returned any time <code>$this-&gt;item-&gt;getPrice()</code> is called in my code. The call to <code>$this-&gt;item-&gt;getPrice()</code> returns another object that you can set the answer on using Phake's fluent api. In the example I called <code>Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100)</code>. The <code>thenReturn()</code> method will bind a static answer to a matcher for <code>getPrice()</code> in the stub map for <code>$this-&gt;item1</code>.</p>"},{"location":"doc/stubbing/#overwriting-existing-stubs","title":"Overwriting Existing Stubs","text":"<p>My shopping cart application is coming right along. I can add items and the total price seems to be accurate. However, while I was playing around with my new cart I noticed a very strange problem. I was playing around with the idea of allowing discounts to be applied to a cart as just additional items that would have a negative price. So while I am playing around with this idea I notice that the math isn't always adding up. If I start with an item that is $100 and then add a discount that is $81.40 I see that the total price isn't adding up to $18.60. This is definitely problematic After doing some further research, I realize I made a silly mistake. I am just using simple floats to calculate the costs. Floats are by nature inaccurate. Once you start using them in mathematical operations they start to show their inadequacy for precision. In keeping with the test driven method of creating code I need to create a unit test this flaw.</p> <pre><code>class ShoppingCartTest extends PHPUnit\\Framework\\TestCase\n{\n      public function testGetSub()\n      {\n          $item1 = Phake::mock(Item::class);\n          $item2 = Phake::mock(Item::class);\n          $item3 = Phake::mock(Item::class);\n\n          Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);\n          Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(200);\n          Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(300);\n\n          $shoppingCart = new ShoppingCart();\n          $shoppingCart-&gt;addItem($item1);\n          $shoppingCart-&gt;addItem($item2);\n          $shoppingCart-&gt;addItem($item3);\n\n          $this-&gt;assertEquals(600, $shoppingCart-&gt;getSubTotal());\n      }\n\n      public function testGetSubTotalWithPrecision()\n      {\n          $item1 = Phake::mock(Item::class);\n          $item2 = Phake::mock(Item::class);\n          $item3 = Phake::mock(Item::class);\n\n          Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);\n          Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(-81.4);\n          Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(20);\n\n          $shoppingCart = new ShoppingCart();\n          $shoppingCart-&gt;addItem($item1);\n          $shoppingCart-&gt;addItem($item2);\n          $shoppingCart-&gt;addItem($item3);\n\n          $this-&gt;assertEquals(38.6, $shoppingCart-&gt;getSubTotal());\n      }\n}\n</code></pre> <p>You can see that I added another test method that uses actual floats for some of the prices as opposed to round numbers. Now when I run my test suite I can see the result.</p> <pre><code>$ phpunit ExampleTests/ShoppingCartTest.php\nPHPUnit 9.5.4 by Sebastian Bergmann and contributors.\n\n..                                                                  2 / 2 (100%)\n\nTime: 00:00.012, Memory: 4.00 MB\n\nOK (2 tests, 2 assertions)\n</code></pre> <p>Once you confirmed that your implementation works, I want to discuss streamlining test cases with you. You will notice that the code in <code>ShoppingCartTest::testGetSubTotalWithPrecision()</code> contains almost all duplicate code when compared to <code>ShoppingCartTest::testGetSub()</code>. If I were to continue following this pattern of doing things I would eventually have tests that are difficult to maintain. Phake allows you to very easily override stubs. This is very important in helping you to reduce duplication in your tests and leads to tests that will be easier to maintain. To overwrite a previous stub you simply have to redefine it. I am going to change <code>ShoppingCartTest::testGetSubTotalWithPrecision()</code> to instead just redefine the <code>getPrice()</code> stubs.</p> <pre><code>class ShoppingCartTest extends PHPUnit\\Framework\\TestCase\n{\n    private ShoppingCart $shoppingCart;\n    private Item $item1;\n    private Item $item2;\n    private Item $item3;\n\n    public function setUp(): void\n    {\n        $this-&gt;item1 = Phake::mock(Item::class);\n        $this-&gt;item2 = Phake::mock(Item::class);\n        $this-&gt;item3 = Phake::mock(Item::class);\n\n        Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100);\n        Phake::when($this-&gt;item2)-&gt;getPrice()-&gt;thenReturn(200);\n        Phake::when($this-&gt;item3)-&gt;getPrice()-&gt;thenReturn(300);\n\n        $this-&gt;shoppingCart = new ShoppingCart();\n        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item1);\n        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item2);\n        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item3);\n    }\n\n    public function testGetSub()\n    {\n        $this-&gt;assertEquals(600, $this-&gt;shoppingCart-&gt;getSubTotal());\n    }\n\n    public function testGetSubTotalWithPrecision()\n    {\n        Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100);\n        Phake::when($this-&gt;item2)-&gt;getPrice()-&gt;thenReturn(-81.4);\n        Phake::when($this-&gt;item3)-&gt;getPrice()-&gt;thenReturn(20);\n\n        $this-&gt;assertEquals(38.6, $this-&gt;shoppingCart-&gt;getSubTotal());\n    }\n}\n</code></pre> <p>If you rerun this test you will get the same results shown in before. The test itself is much simpler though there is much less unnecessary duplication. The reason this works is because the stub map I was referring to in How <code>Phake::when()</code> works isn't really a map at all. It is more of a stack in reality. When a new matcher and answer pair is added to a mock object, it is added to the top of the stack. Then whenever a stub method is called, the stack is checked from the top down to find the first matcher that matches the method that was called. So, when I created the additional stubs for the various <code>Item::getPrice()</code> calls, I was just adding additional matchers to the top of the stack that would always get matched first by virtue of the parameters all being the same.</p>"},{"location":"doc/stubbing/#resetting-a-mocks-stubs","title":"Resetting A Mock's Stubs","text":"<p>If overriding a stub does not work for your particular case and you would rather start over with all default stubs then you can use <code>Phake::reset()</code> and <code>Phake::resetStatic()</code>. These will remove all stubs from a mock and also empty out all recorded calls against a mock. <code>Phake::reset()</code> will do this for instance methods on the mock and <code>Phake::resetStatic()</code> will do this for all static methods on the mock.</p> <pre><code>public function testResettingStubMapper()\n{\n    $mock = Phake::mock(PhakeTest_MockedClass::class);\n    Phake::when($mock)-&gt;foo()-&gt;thenReturn(42);\n\n    $this-&gt;assertEquals(42, $mock-&gt;foo());\n\n    Phake::reset($mock);\n    //$mock-&gt;foo() now returns the default stub which in this case is null\n    $this-&gt;assertNull($mock-&gt;foo());\n}\n\npublic function testResettingCallRecorder()\n{\n    $mock = Phake::mock(PhakeTest_MockedClass::class);\n    $mock-&gt;foo();\n\n    //Will work as normal\n    Phake::verify($mock)-&gt;foo();\n\n    Phake::reset($mock);\n\n    //Will now throw an error that foo was not called\n    Phake::verify($mock)-&gt;foo();\n}\n</code></pre>"},{"location":"doc/stubbing/#stubbing-multiple-calls","title":"Stubbing Multiple Calls","text":"<p>Another benefit of the stub mapping in Phake is that it allows you to very easily stub multiple calls to the same method that use different parameters. In my shopping cart I have decided to add some functionality that will allow me to easily add multiple products that are a part of a group to the shopping cart. To facilitate this I have decided to create a new class called <code>ItemGroup</code>. The <code>ItemGroup</code> object will be constructed with an array of <code>Items</code>. It will have a method on the class that will add all of the items in the group to the given cart and then the total price of items in the cart will be returned.</p> <p>It should be noted that earlier I decided to make a small change to the <code>ShoppingCart::addItem()</code> method to have it return the total price of items in the cart. I figured that this would be nice api level functionality to make working with the system a little bit easier. I would like to take advantage of that change with this code. Here's a stub of the functionality I am considering.</p> <pre><code>/**\n * A group of items that can be added to a cart all at the same time\n */\nclass ItemGroup\n{\n    /**\n     * @param array $items an array of Item objects\n     */\n    public function __construct(array $items)\n    {\n    }\n\n    /**\n     * @param ShoppingCart $cart\n     * @return money The new total value of the cart\n     */\n    public function addItemsToCart(ShoppingCart $cart)\n    {\n    }\n}\n</code></pre> <p>The next test I am going to write now is going to be focusing on this new <code>ItemGroup::addItemsToCart()</code> method. In my test's <code>setUp()</code> method I'll create a new instance of <code>ItemGroup</code> which will require one or more <code>Item</code> implementations. I'll use mocks for those. Then the actual test case I am going to start with will be a test to assert that <code>ItemGroup::addItemsToCart()</code> returns the new shopping cart value. I already know that I am going to need to get this value by looking at the last return value from calls to <code>ShoppingCart::addItem()</code>. To allow for checking this I will mock <code>ShoppingCart</code> and create three stubs for <code>ShoppingCart::addItem()</code>. Each stub will be for a call with a different <code>Item</code>.</p> <pre><code>class ItemGroupTest extends PHPUnit\\Framework\\TestCase\n{\n    private ItemGroup $itemGroup;\n    private Item $item1;\n    private Item $item2;\n    private Item $item3;\n\n    public function setUp(): void\n    {\n        $this-&gt;item1 = Phake::mock(Item::class);\n        $this-&gt;item2 = Phake::mock(Item::class);\n        $this-&gt;item3 = Phake::mock(Item::class);\n\n        $this-&gt;itemGroup = new ItemGroup([ $this-&gt;item1, $this-&gt;item2, $this-&gt;item3 ]);\n    }\n\n    public function testAddItemsToCart()\n    {\n        $cart = Phake::mock(ShoppingCart::class);\n        Phake::when($cart)-&gt;addItem($this-&gt;item1)-&gt;thenReturn(10);\n        Phake::when($cart)-&gt;addItem($this-&gt;item2)-&gt;thenReturn(20);\n        Phake::when($cart)-&gt;addItem($this-&gt;item3)-&gt;thenReturn(30);\n\n        $totalCost = $this-&gt;itemGroup-&gt;addItemsToCart($cart);\n        $this-&gt;assertEquals(30, $totalCost);\n    }\n}\n</code></pre> <p>In this example the <code>ShoppingCart::addItem()</code> method is being stubbed three times. Each time it is being stubbed with a different parameter being passed to <code>addItem()</code>. This a good example of how parameters are also checked whenever Phake looks at a mock object's stub map for answers. The default behavior of argument matching is again a loose equality check. Similar to how you would use the double equals operator in PHP. The other options for argument matching are discussed further in Method Parameter Matchers.</p>"},{"location":"doc/stubbing/#stubbing-consecutive-calls","title":"Stubbing Consecutive Calls","text":"<p>The previous test was a great example for how you can make multiple stubs for a single method however in reality it is not the best way for that particular test to be written. What if the <code>Item</code> objects in an <code>ItemGroup</code> aren't stored in the order they were passed in? I am needlessly binding my test to the order in which objects are stored. Phake provides the ability to map multiple answers to the same stub. This is done simply by chaining the answers together. I could rewrite the test from the previous chapter to utilize this feature of Phake.</p> <pre><code>class ItemGroupTest extends PHPUnit\\Framework\\TestCase\n{\n    private ItemGroup $itemGroup;\n    private Item $item1;\n    private Item $item2;\n    private Item $item3;\n\n    public function setUp(): void\n    {\n        $this-&gt;item1 = Phake::mock(Item::class);\n        $this-&gt;item2 = Phake::mock(Item::class);\n        $this-&gt;item3 = Phake::mock(Item::class);\n\n        $this-&gt;itemGroup = new ItemGroup([ $this-&gt;item1, $this-&gt;item2, $this-&gt;item3 ]);\n    }\n\n    public function testAddItemsToCart()\n    {\n        $cart = Phake::mock(ShoppingCart::class);\n        Phake::when($cart)-&gt;addItem(Phake::anyParameters())-&gt;thenReturn(10)\n            -&gt;thenReturn(20)\n            -&gt;thenReturn(30);\n\n        $totalCost = $this-&gt;itemGroup-&gt;addItemsToCart($cart);\n        $this-&gt;assertEquals(30, $totalCost);\n    }\n}\n</code></pre> <p>You will notice a few of differences between this example and the example in Stubbing Multiple Calls. The first difference is that there is only one call to <code>Phake::when()</code>. The second difference is that I have chained together three calls to <code>thenReturn()</code>. The third difference is instead of passing one of my mock Item objects I have passed the result of the <code>Phake::anyParameters()</code> method. This is a special argument matcher in Phake that essentially says match any call to the method regardless of the number of parameters or the value of those parameters. You can learn more about <code>Phake::anyParameters()</code> in Wildcard Parameters.</p> <p>So, this single call to <code>Phake::when()</code> is saying: \"Whenever a call to <code>$cart-&gt;addItem()</code> is made, regardless of the parameters, return 10 for the first call, 20 for the second call, and 30 for the third call.\" If you are using consecutive call stubbing and you call the method more times than you have answers set, the last answer will continue to be returned. In this example, if <code>$cart-&gt;addItem()</code> were called a fourth time, then 30 would be returned again.</p>"},{"location":"doc/stubbing/#stubbing-reference-parameters","title":"Stubbing Reference Parameters","text":"<p>Occasionally you may run into code that utilizes reference parameters to provide additional output from a method. This is not an uncommon thing to run into with legacy code. Phake provides a custom parameter matcher (these are discussed further in Method Parameter Matchers) that allows you to set reference parameters. It can be accessed using <code>Phake::setReference()</code>. The only parameter to this matcher is the value you would like to set the reference parameter to provided all other parameters match.</p> <pre><code>interface IValidator\n{\n    /**\n     * @parm array $data Data to validate\n     * @parm array &amp;$errors contains all validation errors if the data is not valid\n     * @return boolean True when the data is valid\n     */\n    public function validate(array $data, array &amp;$errors);\n}\n\nclass ValidationLogger implements IValidator\n{\n    private $validator;\n    private $log;\n\n    public function __construct(IValidator $validator, Logger $log)\n    {\n        $this-&gt;validator = $validator;\n        $this-&gt;log = $log;\n    }\n\n    public function validate(array $data, array &amp;$errors)\n    {\n        if (!$this-&gt;validator-&gt;validate($data, $errors))\n        {\n            foreach ($errors as $error)\n            {\n                $this-&gt;log-&gt;info(\"Validation Error: {$error}\");\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n}\n\nclass ValidationLoggerTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testValidate()\n    {\n        //Mock the dependencies\n        $validator = Phake::mock(IValidator::class);\n        $log = Phake::mock(Logger::class);\n        $data = [ 'data1' =&gt; 'value' ];\n        $expectedErrors = ['data1 is not valid'];\n\n        //Setup the stubs (Notice the Phake::setReference()\n        Phake::when($validator)-&gt;validate($data, Phake::setReference($expectedErrors))-&gt;thenReturn(false);\n\n        //Instantiate the SUT\n        $validationLogger = new ValidationLogger($validator, $log);\n\n        //verify the validation is false and the message is logged\n        $errors = [];\n        $this-&gt;assertFalse($validationLogger-&gt;validate($data, $errors));\n        Phake::verify($log)-&gt;info('Validation Error: data1 is not valid');\n    }\n}\n</code></pre> <p>In the example above, I am testing a new class I have created called <code>ValidationLogger</code>. It is a decorator for other implementations of <code>IValidator</code> that allows adding logging to any other validator. The <code>IValidator::validate()</code> method will always return an array of errors into the second parameter (a reference parameter) provided to the method. These errors are what my logger is responsible for logging. So in order for my test to work properly, I will need to be able to set that second parameter as a part of my stubbing call.</p> <p>In the call to <code>Phake::when($validator)-&gt;validate()</code> I have passed a call to <code>Phake::setReference()</code> as the second parameter. This is causing the mock implementation of <code>IValidator</code> to set <code>$errors</code> in <code>ValidationLogger::validate()</code> to the array specified by <code>$expectedErrors</code>. This allows me to quickly and easily validate that I am actually logging the errors returned back in the reference parameter.</p> <p>By default <code>Phake::setReference()</code> will always return true regardless of the parameter initially passed in. If you would like to only set a reference parameter when that reference parameter was passed in as a certain value you can use the <code>when()</code> modifier. This takes a single parameter matcher as an argument. Below, you will see that the test has been modified to call <code>when()</code> on the result of <code>Phake::setReference()</code>. This modification will cause the reference parameter to be set only if the $errors parameter passed to <code>IValidator::validate()</code> is initially passed as an empty array.</p> <pre><code>class ValidationLoggerTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testValidate()\n    {\n        //Mock the dependencies\n        $validator = Phake::mock(IValidator::class);\n        $log = Phake::mock(Logger::class);\n        $data = [ 'data1' =&gt; 'value' ];\n        $expectedErrors = [ 'data1 is not valid' ];\n\n        //Setup the stubs (Notice the Phake::setReference()\n        Phake::when($validator)-&gt;validate($data, Phake::setReference($expectedErrors)-&gt;when([])-&gt;thenReturn(false);\n\n        //Instantiate the SUT\n        $validationLogger = new ValidationLogger($validator, $log);\n\n        //verify the validation is false and the message is logged\n        $errors = [];\n        $this-&gt;assertFalse($validationLogger-&gt;validate($data, $errors));\n        Phake::verify($log)-&gt;info('Validation Error: data1 is not valid');\n    }\n}\n</code></pre> <p>Please note, when you are using <code>Phake::setReference()</code> you still must provide an answer for the stub. If you use this function and your reference parameter is never changed, that is generally the most common reason.</p>"},{"location":"doc/stubbing/#partial-mocks","title":"Partial Mocks","text":"<p>When testing legacy code, if you find that the majority of the methods in the mock are using the <code>thenCallParent()</code> answer, you may find it easier to just use a partial mock in Phake. Phake partial mocks also allow you to call the actual constructor of the class being mocked. They are created using <code>Phake::partialMock()</code>. Like <code>Phake::mock()</code>, the first parameter is the name of the class that you are mocking. However, you can pass additional parameters that will then be passed as the respective parameters to that class\u2019 constructor. The other notable feature of a partial mock in Phake is that its default answer is to pass the call through to the parent as if you were using <code>thenCallParent()</code>.</p> <p>Consider the following class that has a method that simply returns the value passed into the constructor.</p> <pre><code>class MyClass\n{\n    private $value;\n\n    public __construct($value)\n    {\n        $this-&gt;value = $value;\n    }\n\n    public function foo()\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> <p>Using <code>Phake::partialMock()</code> you can instantiate a mock object that will allow this object to function as designed while still allowing verification as well as selective stubbing of certain calls. Below is an example that shows the usage of <code>Phake::partialMock()</code>.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testCallingParent()\n    {\n        $mock = Phake::partialMock(MyClass::class, 42);\n\n        $this-&gt;assertEquals(42, $mock-&gt;foo());\n    }\n}\n</code></pre> <p>Again, partial mocks should not be used when you are testing new code. If you find yourself using them be sure to inspect your design to make sure that the class you are creating a partial mock for is not doing too much.</p>"},{"location":"doc/stubbing/#setting-default-stubs","title":"Setting Default Stubs","text":"<p>You can also change the default stubbing for mocks created with <code>Phake::mock()</code>. This is done by using the second parameter to <code>Phake::mock()</code> in conjunction with the <code>Phake::ifUnstubbed()</code> method. The second parameter to <code>Phake::mock()</code> is reserved for configuring the behavior of an individual mock. <code>Phake::ifUnstubbed()</code> allows you to specify any of the matchers mentioned above as the default answer if any method invocation is not explicitly stubbed. If this configuration directive is not provided then the method will return <code>NULL</code> by default. An example of this can be seen below.</p> <pre><code>class MyClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testDefaultStubs()\n    {\n        $mock = Phake::mock(MyClass::class, Phake::ifUnstubbed()-&gt;thenReturn(42));\n\n        $this-&gt;assertEquals(42, $mock-&gt;foo());\n    }\n}\n</code></pre>"},{"location":"doc/stubbing/#stubbing-magic-methods","title":"Stubbing Magic Methods","text":"<p>Most magic methods can be stubbed using the method name just like you would any other method. The one exception to this is the <code>__call()</code> method. This method is overwritten on each mock already to allow for the fluent api that Phake utilizes. If you want to stub a particular invocation of <code>__call()</code> you can create a stub for the method you are targetting in the first parameter to <code>__call()</code>.</p> <p>Consider the following class.</p> <pre><code>class MagicClass\n{\n    public function __call($method, $args)\n    {\n        return '__call';\n    }\n}\n</code></pre> <p>You could stub an invocation of the <code>__call()</code> method through a userspace call to <code>magicCall()</code> with the following code.</p> <pre><code>class MagicClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testMagicCall()\n    {\n        $mock = Phake::mock(MagicClass::class);\n\n        Phake::when($mock)-&gt;magicCall()-&gt;thenReturn(42);\n\n        $this-&gt;assertEquals(42, $mock-&gt;magicCall());\n    }\n}\n</code></pre> <p>If for any reason you need to explicitly stub calls to <code>__call()</code> then you can use <code>Phake::whenCallMethodWith()</code>. The matchers passed to <code>Phake::whenCallMethod()</code> will be matched to the method name and array of arguments similar to what you would expect to be passed to a <code>__call()</code> method. You can also use <code>Phake::anyParameters()</code> instead.</p> <pre><code>class MagicClassTest extends PHPUnit\\Framework\\TestCase\n{\n    public function testMagicCall()\n    {\n        $mock = Phake::mock(MagicClass::class);\n\n        Phake::whenCallMethodWith('magicCall', [])-&gt;isCalledOn($mock)-&gt;thenReturn(42);\n\n        $this-&gt;assertEquals(42, $mock-&gt;magicCall());\n    }\n}\n</code></pre>"},{"location":"doc/cookbooks/annotations/","title":"Using Annotations","text":"<p>To make your tests less verbose and easier to read/write, Phake allow you to initialize your objects properties using annotations. To do so, you need to add the <code>Mock</code> annotation on your object properties you would like to mock and call <code>Phake::initAnnotations($object)</code>.</p> <p>** Example **</p> PHP8PHP7 <pre><code>&lt;?php\n\nuse Phake\\Mock;\nuse PHPUnit\\Framework\\TestCase;\n\nclass FooTest extends TestCase\n{\n    #[Mock]\n    private MyClass $typedMock;\n\n    #[Mock(MyClass::class)]\n    private $untypedMock;\n\n    #[Mock(class: MyClass::class)]\n    private $untypedMock2;\n\n    public function setUp(): void\n    {\n        Phake::initAnnotations($this);\n    }\n\n    public function testInitAnnotations(): void\n    {\n        $this-&gt;assertInstanceOf(MyClass::class, $this-&gt;typedMock);\n        $this-&gt;assertInstanceOf(MyClass::class, $this-&gt;untypedMock);\n        $this-&gt;assertInstanceOf(MyClass::class, $this-&gt;untypedMock2);\n    }\n}\n</code></pre> <pre><code>&lt;?php\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass MyClassTest extends TestCase\n{\n    /**\n     * @Mock\n     */\n    private MyClass $typedMock;\n\n    /**\n     * @Mock\n     * @var MyClass\n     */\n    private $untypedMock;\n\n    public function setUp(): void\n    {\n        Phake::initAnnotations($this);\n    }\n\n    public function testInitAnnotations(): void\n    {\n        $this-&gt;assertInstanceOf(MyClass::class, $this-&gt;typedMock);\n        $this-&gt;assertInstanceOf(MyClass::class, $this-&gt;untypedMock);\n    }\n}\n</code></pre> <p>If you're on PHP8 but want to use the old PHP7 annotations, you can add this line in your bootstrap.</p> <pre><code>Phake\\Annotation\\MockInitializer::setDefaultReader(new Phake\\Annotation\\LegacyReader());\n</code></pre>"}]}